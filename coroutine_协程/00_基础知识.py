'''
基本概念
并发:值一个时间段内,有几个程序在同一个cpu上运行,但是任意时刻只有一个程序在cpu上运行
    (操作系统原理:一个cpu在同一时间点只有可能去执行一个程序,cpu的运转速度非常高,cpu可以再短时间内完成多个程序的切换)

并行:任意时刻上,有多个程序同时运行在多个cpu上
     (并行的数量和cpu的数量是一直的)

同步:指代码进行io操作时,必须等待io操作完成才返回的调用方式
    (io操作:包含磁盘读写,网络请求,.....等)

异步:指代码调用io操作时,不必等待io操作完成的调用方式
    (多线程,协程)


阻塞:调用函数时候,当前线程被挂起

非阻塞:调用函数时候,当前线程不会被挂起,而是立即返回


区分同步,异步和阻塞,非阻塞(如果不理解,不必强行分清)

同步,异步:消息之间的一种通信机制
阻塞,非阻塞:函数调用的一种机制

'''


'''
unix下的五种io模型

阻塞式io :平时编码汇总最常用到
非阻塞式io :监听一个请求(socket,文件句柄),不断轮询,消耗cpu
io复用 : 进程受阻于select调用,select/pool和epoll,监听多个请求(socket,文件句柄) ,目前高并发技术中使用最广泛的
         将数据从系统内核(底部内存:内存中留给操作系统的空间)赋值doa用户空间的时间(内存中用户程序占用的空间)时间还是省不了
         还有提升的空间
信号驱动io :用的非常少
异步io(posix的aio_系列函数):才是真正意义上的异步io,我们现在接触到的高并发的框架没有使用aio,而是使用io多路复用技术,
                          io多路复用技术更成熟,稳定
                          
'''

'''
io多路复用中的select/pool/epool的理解

select/pool/epool都是io多路复用的机制,
io多路复用就是通过一种机制,一个进程就可以监视多个描述符,一旦某个描述符就绪(一般救赎读就绪或者写就绪),能够通知程序进行
相应的读写操作
但select/pool/epool本质上都是同步io,因为他们都需要在读写时间就绪后自己负责进行读写,也就是说读写过程是阻塞的
而异步io不需要自己读写,异步io的实现会负责把数据从内核拷贝到用户空间


epool并不一定比select好
在高并发的情况下,连接活跃度不是很高,epool比select好  web高并发网站
在并发性不高,同时连接很活跃,select比epool好   游戏开发





'''