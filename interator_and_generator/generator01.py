
'''
调用cash函数,cash函数中含有yield,所以cash函数是一个生成器,返回一个迭代器
结果:>>

第0次执行我
100
第1次执行我
代码从我开始往下执行
代码已经执行完了
100
'''

def cash(account):
    while account>0:
        account -=100
        yield 100
        print('代码从我开始往下执行')
        print('代码已经执行完了')

a = cash(500)  # a成为一个生成器对象

print(a)   #检测到函数中存在yield的时候,函数暂时运行
print('第0次执行我')
print(a.__next__()) #当执行到第一个next时候,才开始正真的调用函数
print('第1次执行我')
print(a.__next__()) #当执行到第一个next的时候,继续调用函数,根据yield特性,会从上一次中断的位置据需执行函数

'''
 从运行结果可以推断出，当程序进行到a = cash(500) 时，
 函数并没有进行调用而是继续往下走打印“第0次执行我”，为什么？
 其实正是因为在函数定义的时候，检测到函数中写了yield关键字，此时这个函数就变成了一个生成器，
 于是函数暂停运行；当执行到第一个print(a.__next__()) 时，才开始真正的调用函数了，
 函数执行到yield 100 时，根据yield的特性，函数中断返回100并打印，程序继续向下执行打印“第1次执行我”；
 当执行到第二个print(a.__next__()) 时，继续调用函数，根据yield的特性，会接着上一次中断的位置继续执行函数，
 于是打印“从我开始往下执行！”“代码已经执行完啦”，而根据函数中的while循环，会再次执行循环代码，直到 yield 100，
 函数再次中断返回100并打印。到此，程序执行完毕！

'''