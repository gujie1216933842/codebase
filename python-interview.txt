1.python是一种解释型语言,运行之前不需要编译,类似的语言有php,ruby

2.python动态类型语言,指的是在你声明变量时,不需要声明变量的类型,直接写 x =1 或者 x = 'abc' 程序不会报错

3.python的优点
  a.python代码编写快,
  b.用途广泛,被称为胶水语言
  c.让程序员专注于算法和数据结构的设计,而不用处理底层的细节

4.python和多线程(multi-threading)
  python并不支持正真意义上的多线程,python中提供了多线程的包,但是你想通过多线程提高代码的速度,使用多线程包并不是一个好的主意.
  python中有一个被称为(global interpreter lock)gil的东西,它会确保在任何时候的的多线程中,只有一个被执行.而且线程执行速度非常快,会让你认为线程是并行执行的,但是实际上是轮流执行的.经过gil这道关卡处理,会增加执行的开销.这意味着,如果你想提高代码的运行速度,使用threading包并不是一个很好的方法

  不过还是有很多理由促使我们去使用threading包,如果你想同时执行一些任务,而且不考虑效率问题,那么使用这个包是完全没有问题的,而且也很方便.
  但是大部分情况下,并不是这么一回事,你会希望把多线程的部分外包给操作系统完成(通过开启多个进程),或者某些调用你的python代码的外部程序(例如spark和hadoop),又或者是你的python代码调用其他代码

5.python循环遍历range()的边界问题
    >>> range(1,4)
    [1, 2, 3]
    >>> range(4)
    [0, 1, 2, 3]
    >>> range(1,4,2)  
    [1, 3]


6.*args,**kwargs,这两个参数是什么意思,我们为什么要使用它
答案:
如果我们不确认要往函数中去传递多少个参数,或者我们想往函数中以列表或者元组的形式传参数,就要使用*args    
如果我们不知道要往函数中传递多少个关键词参数,或者像传入字典的值作为关键字参数时,就用**kwargs
args和kwargs是两个约定俗成的标记用法,你也可以用*janc和**jajsd,但是这样并不太妥


7.@classmethod, @staticmethod, @property分别表示什么意思
背景知识回顾:装饰器是一种特殊的函数,要么接受函数作为输入参数,并返回一个函数,要么接受一个类作为输入参数,并返回一个类,
@:语法糖
此处待重点查看
@classmethod 类方法,不需要实例化,可类名直接调用
@staticmethod 静态方法 
相同点:都不需要实例化
区别:staticmethod并不是因为不想创建实例才声明的，而是声明该方法不会更改实例本身的数据。
classmethod也并不是因为不想创建实例才声明的，而是为了实现对类本身的操作（传入cls之后就可以对自身的属性和方法进行操作）
静态方法是和类与实例都没有关系的，完全可以使用一般方法代替，但是使用静态方法可以更好的组织代码，防止代码变大后变得比较混乱。类方法是可以替代静态方法的。静态方法不能在继承中修改。

python类里面的方法分为  实例方法(第一参数:self),类方法(第一参数:cls),静态方法(没有第一参数要求)

      






8.python里面理解赋值,深拷贝,浅拷贝的区别
赋值: = 就是创建了对象的一个新的引用,修改其中任意一个变量都会影响到另一个
浅拷贝:创建一个新的对象,但是它包含的是对原始对象的引用(如果用引用的方式修改其中的一个对象,  另一个对象也会随之改变,)copy()
深拷贝:创建一个新对象,并且递归的赋值它所有的对象(修改其中一个,另一个不会改变)deep_copy()     







https://www.cnblogs.com/Allen-rg/p/7693394.html

https://www.cnblogs.com/tom-gao/p/6645859.html




9.网络通信分层(分别解决什么问题)
应用层:描述传输的数据时什么格式 (两个公司签订的购货合同) http ,ssh 
传输层:不管要传输的数据时什么内容,只负责保证数据送达即可,(快递公司)
       TCP(相当于挂号信)
       UDP(相当于平邮)
网络层:解决时是位置问题
数据链路层: 采用什么方式传输(用什么方式送快递,飞机还是火车)

进行传输的时候,并不一定非要应用层,qq据说没有

浏览器(客户端)访问服务器步骤
1.首先在应用层这部分:将数据封装成http协议的报文,
2.传输层:socket connect werite()      
         socket bind listen  read()






10.tornado原理理解
1>.ioloop是tornado运行的核心
2>.ioloop封装了操作管理epoll的工作
3>.ioloop实例启动时,ioloop将服务器监听的socket添加到epoll容器中,然后循环等待epoll返回处理socket

4>.当客户端发起连接后,ioloop从epoll容器中拿到服务器监听的socket,并调用服务器实例处理监听socket的方法,接收连接请求,并将新的客户端对应的socket添加到epoll容器中,然后继续循环等待epoll返回可处理的socket

5>当客户端发送过来的请求数据后,ioloop从epoll中拿到了接收数据的socket,并调用服务器实例处理该传输socket的方法,从socket读取处http报文数据,解析后调用application的实例,进行路由分发,实例化具体的http方法,生成响应数据给客户端,完成请求处理

6>当与客户端对应的socket可写是,ioloop从epoll中拿到了对应可写的socket,将缓冲区中对应的响应报文数据写入doasocket中传回给客户端,完成请求处理
7>epoll每次只返回给ioloop可以处理的socket,然后ioloop对拿到的socket依次进行处理,有效充分地利用cpu时间,进而达到提升支持高并发的能力








