1.python是一种解释型语言,运行之前不需要编译,类似的语言有php,ruby

2.python动态类型语言,指的是在你声明变量时,不需要声明变量的类型,直接写 x =1 或者 x = 'abc' 程序不会报错

3.python的优点
  a.python代码编写快,
  b.用途广泛,被称为胶水语言
  c.让程序员专注于算法和数据结构的设计,而不用处理底层的细节

4.python和多线程(multi-threading)
  python并不支持正真意义上的多线程,python中提供了多线程的包,但是你想通过多线程提高代码的速度,使用多线程包并不是一个好的主意.
  python中有一个被称为(global interpreter lock)gil的东西,它会确保在任何时候的的多线程中,只有一个被执行.而且线程执行速度非常快,会让你认为线程是并行执行的,但是实际上是轮流执行的.经过gil这道关卡处理,会增加执行的开销.这意味着,如果你想提高代码的运行速度,使用threading包并不是一个很好的方法

  不过还是有很多理由促使我们去使用threading包,如果你想同时执行一些任务,而且不考虑效率问题,那么使用这个包是完全没有问题的,而且也很方便.
  但是大部分情况下,并不是这么一回事,你会希望把多线程的部分外包给操作系统完成(通过开启多个进程),或者某些调用你的python代码的外部程序(例如spark和hadoop),又或者是你的python代码调用其他代码

5.python循环遍历range()的边界问题
    >>> range(1,4)
    [1, 2, 3]
    >>> range(4)
    [0, 1, 2, 3]
    >>> range(1,4,2)  
    [1, 3]


6.*args,**kwargs,这两个参数是什么意思,我们为什么要使用它
答案:
如果我们不确认要往函数中去传递多少个参数,或者我们想往函数中以列表或者元组的形式传参数,就要使用*args    
如果我们不知道要往函数中传递多少个关键词参数,或者像传入字典的值作为关键字参数时,就用**kwargs
args和kwargs是两个约定俗成的标记用法,你也可以用*janc和**jajsd,但是这样并不太妥


7.@classmethod, @staticmethod, @property分别表示什么意思
背景知识回顾:装饰器是一种特殊的函数,要么接受函数作为输入参数,并返回一个函数,要么接受一个类作为输入参数,并返回一个类,
@:语法糖
此处待重点查看
@classmethod 类方法,不需要实例化,可类名直接调用
@staticmethod 静态方法 
相同点:都不需要实例化
区别:staticmethod并不是因为不想创建实例才声明的，而是声明该方法不会更改实例本身的数据。
classmethod也并不是因为不想创建实例才声明的，而是为了实现对类本身的操作（传入cls之后就可以对自身的属性和方法进行操作）
静态方法是和类与实例都没有关系的，完全可以使用一般方法代替，但是使用静态方法可以更好的组织代码，防止代码变大后变得比较混乱。类方法是可以替代静态方法的。静态方法不能在继承中修改。

python类里面的方法分为  实例方法(第一参数:self),类方法(第一参数:cls),静态方法(没有第一参数要求)
http://baijiahao.baidu.com/s?id=1570268511794462&wfr=spider&for=pc
      






8.python里面理解赋值,深拷贝,浅拷贝的区别
赋值: = 就是创建了对象的一个新的引用,修改其中任意一个变量都会影响到另一个
浅拷贝:创建一个新的对象,但是它包含的是对原始对象的引用(如果用引用的方式修改其中的一个对象,  另一个对象也会随之改变,)copy()
深拷贝:创建一个新对象,并且递归的赋值它所有的对象(修改其中一个,另一个不会改变)deep_copy()     




https://www.cnblogs.com/Allen-rg/p/7693394.html

https://www.cnblogs.com/tom-gao/p/6645859.html




9.网络通信分层(分别解决什么问题)
应用层:描述传输的数据时什么格式 (两个公司签订的购货合同) http ,ssh 
传输层:不管要传输的数据时什么内容,只负责保证数据送达即可,(快递公司)
       TCP(相当于挂号信)
       UDP(相当于平邮)
网络层:解决时是位置问题
数据链路层: 采用什么方式传输(用什么方式送快递,飞机还是火车)

进行传输的时候,并不一定非要应用层,qq据说没有

浏览器(客户端)访问服务器步骤
1.首先在应用层这部分:将数据封装成http协议的报文,
2.传输层:socket connect werite()      
         socket bind listen  read()






10.tornado原理理解
1>.ioloop是tornado运行的核心
2>.ioloop封装了操作管理epoll的工作
3>.ioloop实例启动时,ioloop将服务器监听的socket添加到epoll容器中,然后循环等待epoll返回处理socket

4>.当客户端发起连接后,ioloop从epoll容器中拿到服务器监听的socket,并调用服务器实例处理监听socket的方法,接收连接请求,并将新的客户端对应的socket添加到epoll容器中,然后继续循环等待epoll返回可处理的socket

5>当客户端发送过来的请求数据后,ioloop从epoll中拿到了接收数据的socket,并调用服务器实例处理该传输socket的方法,从socket读取处http报文数据,解析后调用application的实例,进行路由分发,实例化具体的http方法,生成响应数据给客户端,完成请求处理

6>当与客户端对应的socket可写是,ioloop从epoll中拿到了对应可写的socket,将缓冲区中对应的响应报文数据写入doasocket中传回给客户端,完成请求处理
7>epoll每次只返回给ioloop可以处理的socket,然后ioloop对拿到的socket依次进行处理,有效充分地利用cpu时间,进而达到提升支持高并发的能力



11.编码风格:pep8
   tab空格之类

12.多任务
   fork能在程序中创建新的进程
   a.理解程序和进程
   程序:一段可执行的代码
   进程:程序执行占用的资源
   举例:一个exe程序,在没打开之前就是一个程序,打开之后就是一个进程.程序是没有生命的,而进程是有生命的
   (便于理解:右击,点开windows桌面启动任务管理器)

fork


13.python高并发
如果一个问题不知道从何下手的时候，可以分解成小问题，来一块一块解决！

高并发是什么？简单点说，就是同一时间内，大量的请求服务器，这个大量一般是指千万级以上的请求次数。

不要被“高并发”这3个字吓到，一个系统真正需要高并发的地方并不多，可能是一个接口或者几个接口，但这部分功能很重要。

一，Nginx要做负载均衡
二，程序层面做多线程，锁等机制
三，数据库层面处理
四，服务器配置要尽量高
五，可能还有其他的方案



14.理解python中的生成器,迭代器

生成器:列表元素可以按照某种算法推算出来,那我们可以在循环过程中不断推算出后续的元素,这样就不必创建完整的list,节省大量的内存空间,python中一边循环一边计算的机制,称之为生成器



a.凡是可以用for 循环的都是 可迭代的
b.凡是可以用next()函数的对象都是 迭代类型
c.集合数据类型list dict str 等都是可迭代的  ,但不是迭代器 ,不过可以通过  inter()函数获得一个迭代器对象





15.理解进程,线程,协程
进程是cpu资源分配的最小单位，线程是cpu调度的最小单位
进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源
进程，在一定的环境下，把静态的程序代码运行起来，通过使用不同的资源，来完成一定的任务。

Threading用于提供线程相关的操作。线程是应用程序中工作的最小单元，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

因为协程是用户自己来编写调度逻辑的，对CPU来说，协程其实是单线程，所以CPU不用去考虑怎么调度、切换上下文，这就省去了CPU的切换开销，所以协程在一定程度上又好于多线程。

所谓协程，其实就是在单线程的环境下的yield程序。

线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。

协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程。  gevent模块 greenlet库


python多线程本质是单线程的原因:
python的GIL，也就是全局解释器锁。在编程语言的世界，python因为GIL的问题广受诟病，因为它在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程。所以我们经常能发现，python中的多线程编程有时候效率还不如单线程，就是因为这个原因。

















